type AttackAction = (square: Square) => void;
type PushAction = (square: Square, isDoublePush: Boolean) => void;
type ForAllAttacks = (square: Square, directions: number[], action: AttackAction) => void;

const file_a: number = 0;
const file_b: number = 1;
const file_c: number = 2;
const file_d: number = 3;
const file_e: number = 4;
const file_f: number = 5;
const file_g: number = 6;
const file_h: number = 7;

const rank_1: number = 0;
const rank_2: number = 1;
const rank_3: number = 2;
const rank_4: number = 3;
const rank_5: number = 4;
const rank_6: number = 5;
const rank_7: number = 6;
const rank_8: number = 7;

function index(file: number, rank: number): number {
    return file + rank * 10 + 21
}

function rank(index: number): number {
    return Math.floor(index / 10) - 2;
}

function file(index: number): number {
    return index % 10 - 1;
}

let directionN = +10;
let directionNNE = +21;
let directionNE = +11;
let directionENE = +12;
let directionE = +1;
let directionESE = -8;
let directionSE = -9;
let directionSSE = -19;
let directionS = -10;
let directionSSW = -21;
let directionSW = -11;
let directionWSW = -12;
let directionW = -1;
let directionWNW = +8;
let directionNW = +9;
let directionNNW = +19;

const cardinalDirections = [directionN, directionE, directionS, directionW];
const intercardinalDirections = [directionNE, directionSE, directionSW, directionNW];
const cardinalAndIntercardinalDirections = [...cardinalDirections, ...intercardinalDirections];
const secondaryIntercardinalDirections = [directionNNE, directionENE, directionESE, directionSSE, directionSSW, directionWSW, directionWNW, directionNNW];

class Man {
    readonly side: Side;
    readonly squaresRoot: Square;

    constructor(side: Side) {
        this.side = side;
        this.squaresRoot = new Square(-1, null);
    }

    forEachSquare(squareAction: AttackAction) {
        for (let square = this.squaresRoot.Next; square != this.squaresRoot; square = square.Next) {
            squareAction(square);
        }
    }
}

class Square {
    readonly index: number;
    man: Man | null;
    private _next: Square;
    private _previous: Square;

    constructor(index: number, man: Man) {
        this.index = index;
        this.man = man;
        this._next = this;
        this._previous = this;
    }

    get Next(): Square {
        return this._next;
    }

    Set(man: Man | null) {
        if (this.man) this.Remove();
        this.man = man;
        if (this.man) man.squaresRoot.Insert(this);
    }

    private Insert(square: Square) {
        square._previous = this._previous;
        square._next = this;
        this._previous._next = square;
        this._previous = square;
    }

    private Remove() {
        this._previous._next = this._next;
        this._next._previous = this._previous;
    }
}

class Side {
    readonly pushDirection: number;
    readonly pawnCaptureDirections: number[];
    readonly relativeRanks: number[];

    readonly King: Man;
    readonly Queen: Man;
    readonly Rook: Man;
    readonly Bishop: Man;
    readonly Knight: Man;
    readonly Pawn: Man;

    constructor(isWhite: Boolean) {
        this.pushDirection = isWhite ? directionN : directionS;
        this.pawnCaptureDirections = isWhite ? [directionNW, directionNE] : [directionSE, directionSW];
        this.relativeRanks = isWhite ? [0, 1, 2, 3, 4, 5, 6, 7] : [7, 6, 5, 4, 3, 2, 1, 0];

        this.King = new Man(this);
        this.Queen = new Man(this);
        this.Rook = new Man(this);
        this.Bishop = new Man(this);
        this.Knight = new Man(this);
        this.Pawn = new Man(this);
    }
}

class Board {
    readonly White: Side;
    readonly Black: Side;

    friendly: Side;
    Enemy: Side;

    readonly Squares: (Square | null)[];

    constructor() {
        this.White = new Side(true);
        this.Black = new Side(false);

        this.friendly = this.White;
        this.Enemy = this.Black;

        this.Squares = new Array(120);

        for (let rank: number = rank_1; rank <= rank_8; ++rank) {
            for (let file: number = file_a; file <= file_h; ++file) {
                let i = index(file, rank);
                this.Squares[i] = new Square(i, null);
            }
        }

        this.Squares[index(file_a, rank_1)].Set(this.White.Rook);
        this.Squares[index(file_a, rank_8)].Set(this.Black.Rook);

        this.Squares[index(file_b, rank_1)].Set(this.White.Knight);
        this.Squares[index(file_b, rank_8)].Set(this.Black.Knight);

        this.Squares[index(file_c, rank_1)].Set(this.White.Bishop);
        this.Squares[index(file_c, rank_8)].Set(this.Black.Bishop);
        
        this.Squares[index(file_d, rank_1)].Set(this.White.Queen);
        this.Squares[index(file_d, rank_8)].Set(this.Black.Queen);

        this.Squares[index(file_e, rank_1)].Set(this.White.King);
        this.Squares[index(file_e, rank_8)].Set(this.Black.King);

        this.Squares[index(file_f, rank_1)].Set(this.White.Bishop);
        this.Squares[index(file_f, rank_8)].Set(this.Black.Bishop);

        this.Squares[index(file_g, rank_1)].Set(this.White.Knight);
        this.Squares[index(file_g, rank_8)].Set(this.Black.Knight);

        this.Squares[index(file_h, rank_1)].Set(this.White.Rook);
        this.Squares[index(file_h, rank_8)].Set(this.Black.Rook);

        for (let file: number = file_a; file <= file_h; ++file) {
            this.Squares[index(file, rank_2)].Set(this.White.Pawn);
            this.Squares[index(file, rank_7)].Set(this.Black.Pawn);
        }
    }

    GetSquare(square: Square, direction: number): Square | null {
        return this.Squares[square.index + direction];
    }

    ForAllStepAttacks(square: Square, directions: number[], action: AttackAction) {
        for (let eachDirection of directions) {
            action(this.GetSquare(square, eachDirection));
        }
    }

    ForAllRayAttacks(square: Square, directions: number[], action: AttackAction) {
        for (let eachDirection of directions) {
            for (let eachSquare = this.GetSquare(square, eachDirection); eachSquare != null; eachSquare = this.GetSquare(eachSquare, eachDirection)) {
                action(eachSquare);
                if (eachSquare.man != null) break;
            }
        }
    }

    ForAllPawnPushes(fromSquare: Square, action: PushAction) {
        let fromRelativeRank = this.friendly.relativeRanks[rank(fromSquare.index)];
        let pushToSquare = this.GetSquare(fromSquare, this.friendly.pushDirection);
        if (pushToSquare) {
            if (!pushToSquare.man) {
                action(pushToSquare, false);
                if (fromRelativeRank == rank_2) {
                    let doublePushTo = this.GetSquare(pushToSquare, this.friendly.pushDirection);
                    if (doublePushTo && !doublePushTo.man) {
                        action(doublePushTo, true);
                    }
                }
            }
        }        
    }

    SwitchSides() {
        [this.friendly, this.Enemy] = [this.Enemy, this.friendly];
    }

    MakeMove(move: Move) {
        for (let moveStep of move.Steps) {
            moveStep.Square.Set(moveStep.NewMan);
        }
        this.SwitchSides();
    }

    UnmakeMove(move: Move) {
        for (let i = move.Steps.length - 1; i >= 0; --i) {
            move.Steps[i].Square.Set(move.Steps[i].OldMan);
        }
        this.SwitchSides();
    }
 }

class MoveStep {
    readonly Square: Square;
    readonly OldMan: Man | null;
    readonly NewMan: Man | null;

    constructor(square: Square, newMan: Man | null) {
        this.Square = square;
        this.OldMan = square.man;
        this.NewMan = newMan; 
    }
}

class Move {
    readonly Steps: MoveStep[];

    constructor() {
        this.Steps = [];
    }
}

function GenerateMoves(board: Board): Move[] {
    let moves: Move[] = [];

    AccumPieceMoves(board.friendly.King, board.ForAllStepAttacks, cardinalAndIntercardinalDirections, moves);
    AccumPieceMoves(board.friendly.Queen, board.ForAllRayAttacks, cardinalAndIntercardinalDirections, moves);
    AccumPieceMoves(board.friendly.Rook, board.ForAllRayAttacks, cardinalDirections, moves);
    AccumPieceMoves(board.friendly.Bishop, board.ForAllRayAttacks, intercardinalDirections, moves);
    AccumPieceMoves(board.friendly.Knight, board.ForAllStepAttacks, secondaryIntercardinalDirections, moves);

    return moves;
}

function AccumPieceMoves(piece: Man, forAllAttacks: ForAllAttacks, directions: number[], moves: Move[]) {
    piece.forEachSquare(fromSquare => {
        let manUpStep = new MoveStep(fromSquare, null);
        forAllAttacks(fromSquare, directions, toSquare => {
            if (toSquare.man && toSquare.man.side == piece.side) return;
            let move = new Move();
            move.Steps.push(manUpStep);
            move.Steps.push(new MoveStep(toSquare, piece));
            moves.push(move);
        });
    });
}

function AccumPawnMoves(pawn: Man, board: Board, moves: Move[]) {
    pawn.forEachSquare(fromSquare => {
        let pawnUpStep = new MoveStep(fromSquare, null);
        board.ForAllPawnPushes(fromSquare, (toSquare, isDoublePush) => {

        });
        board.ForAllStepAttacks(fromSquare, pawn.side.pawnCaptureDirections, toSquare => {
            if (toSquare.man && toSquare.man.side == pawn.side) return;
            let move = new Move();
            move.Steps.push(pawnUpStep);
            move.Steps.push(new MoveStep(toSquare, pawn));
            moves.push(move);
        });
    });
}